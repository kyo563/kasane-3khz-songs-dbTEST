<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <meta name="theme-color" content="#8bcf90">
  <title>æ­Œå”±æ›²ãƒ»ä¸€ç™ºãƒã‚¿ æ¤œç´¢ï¼ˆå±¥æ­´ é«˜é€ŸåŒ–ç‰ˆï¼‰</title>
  <style>
    :root{
      --bg:#a9dba3; --card:#ffffff; --card-soft:#f2fbff; --text:#204034; --muted:#4f6f65; --line:#bddbc9;
      --thead:#d3ebdd; --focus:#56adeb; --tab-bg:#e9f7ed; --tab-active:#77c8f6; --tab-border:#9bc8b3; --link:#1f79bc;
      --chip-bg:#e3f4ea; --chip-text:#2c5646; --accent:#56adeb;
    }
    *{box-sizing:border-box}
    body{
      background:linear-gradient(160deg,#98fb98 0%,#78bced 100%);
      color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      line-height:1.6;
      margin:0;
      padding:14px;
      overflow:hidden;
    }
    .app-shell{max-width:760px;margin:0 auto}
    .list-layout{
      height:100dvh;
      min-height:320px;
      position:relative;
    }
    .card{background:linear-gradient(160deg,var(--card) 0%,var(--card-soft) 100%);border:1px solid var(--line);border-radius:18px;padding:16px;box-shadow:0 14px 24px rgba(29,77,60,.12)}
    #filter-panel{
      position:fixed;
      top:14px;
      left:50%;
      transform:translateX(-50%);
      width:min(760px,calc(100vw - 28px));
      z-index:50;
      padding-bottom:42px;
      overflow:hidden;
      transition:padding .2s ease,max-height .2s ease;
    }
    .hero{margin-bottom:12px}
    .hero-title{margin:0;font-size:20px;line-height:1.35;letter-spacing:.02em}
    .hero-sub{margin:6px 0 0;color:var(--muted);font-size:13px}

    .topbar{display:flex;align-items:center;gap:12px;flex-wrap:wrap;justify-content:space-between;margin-bottom:8px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;flex:1}
    .tab{appearance:none;border:1px solid var(--tab-border);background:var(--tab-bg);color:var(--text);border-radius:999px;padding:10px 15px;font-size:14px;cursor:pointer;transition:.2s}
    .tab[aria-selected="true"]{background:var(--tab-active);border-color:transparent;color:#062033;font-weight:700;box-shadow:0 8px 18px rgba(76,201,240,.35)}
    .tab:focus{outline:none}
    .limit-wrap{display:flex;align-items:center;gap:8px;background:#ecf8f1;border:1px solid var(--line);padding:6px 8px;border-radius:999px}
    #limit{padding:6px 10px;font-size:14px;line-height:1.2;width:auto;min-width:88px;border-radius:999px}

    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .row>*{flex:1}
    #q{flex:8 1 0}
    #clear-search{flex:2 1 0;min-width:84px}
    input[type="search"],select{width:100%;padding:12px 14px;border:1px solid #9cc8b6;border-radius:13px;font-size:16px;background:#f7fffb;color:var(--text);outline:none}
    :where(button,[href],input,select):focus-visible{outline:3px solid var(--focus);outline-offset:2px}
    input::placeholder{color:#759789}

    .dm-wrap{display:flex;align-items:center;gap:8px;margin-top:8px}
    .dm-select-wrap{flex:7 1 0}
    .dm-btn-wrap{flex:3 1 0;display:flex}
    #dm-select{width:100%;padding:6px 10px;font-size:14px;line-height:1.2}
    .btn{appearance:none;border:1px solid transparent;background:linear-gradient(135deg,#4cc9f0,#4895ef);color:#05223d;border-radius:12px;padding:10px 12px;font-size:14px;font-weight:700;cursor:pointer}
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform:translateY(1px)}
    .btn-full{width:100%}
    .btn-subtle{background:#f2faf5;color:#285243;border-color:#9cc8b6}

    .muted{color:var(--muted);font-size:13px}
    .server-response{margin-top:6px;padding:6px 10px;border:1px solid var(--line);border-radius:10px;background:#eef8f1;font-size:12px;color:#33584b}
    .server-response.loading{background:#eef6ff;border-color:#9fc3df;color:#234f70}
    .server-response.ok{background:#e9faed;border-color:#9fceaa;color:#22543b}
    .server-response.error{background:#fff1f1;border-color:#e1adad;color:#7a3434}
    .server-monitor{margin-top:8px;padding:8px 10px;border:1px solid var(--line);border-radius:10px;background:#f4fbf7}
    .server-monitor-head{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:6px}
    .server-monitor-title{font-size:12px;color:#33584b;font-weight:700}
    .server-monitor-body{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:4px 8px;font-size:12px;color:#33584b}
    .server-monitor-pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;font-size:11px;border:1px solid var(--line);background:#eff9f2}
    .server-monitor-pill.ok{background:#e9faed;border-color:#9fceaa;color:#22543b}
    .server-monitor-pill.warn{background:#fff8e8;border-color:#e6c987;color:#7c5b22}
    .server-monitor-pill.error{background:#fff1f1;border-color:#e1adad;color:#7a3434}
    #server-monitor-refresh{padding:4px 9px;border-radius:999px;font-size:12px}
    .stats-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#eff9f2;font-size:12px;color:#345c4e}
    .quick-filters{display:flex;gap:8px;overflow-x:auto;padding-bottom:4px;margin-top:10px}
    .filter-chip{appearance:none;border:1px solid #95c4ae;border-radius:999px;background:#eff9f2;color:#2b5244;padding:6px 12px;font-size:13px;white-space:nowrap;cursor:pointer}
    .filter-chip.active{background:linear-gradient(135deg,#6dd3ff,#6fb1ff);color:#05233d;border-color:transparent;font-weight:700}
    .input-dock{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      z-index:40;
      padding:10px 12px calc(10px + env(safe-area-inset-bottom));
      background:linear-gradient(180deg,rgba(104,170,136,0) 0%,rgba(110,170,140,.76) 30%,rgba(110,170,140,.9) 100%);
      backdrop-filter:blur(4px);
    }
    .input-console{
      max-width:760px;
      margin:0 auto;
      background:linear-gradient(160deg,var(--card) 0%,var(--card-soft) 100%);
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px;
      box-shadow:0 12px 24px rgba(29,77,60,.16);
    }
    .toast{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);background:rgba(37,86,70,.92);color:#fff;padding:10px 14px;border-radius:10px;font-size:14px;opacity:0;transition:opacity .2s}
    .toast.show{opacity:1}
    .to-top{position:fixed;right:16px;bottom:134px;z-index:35;display:none;appearance:none;border:1px solid #91c0aa;background:#eff9f2;color:#285243;border-radius:999px;padding:10px 12px;font-size:13px;cursor:pointer;box-shadow:0 8px 18px rgba(29,77,60,.18)}
    .to-top.show{display:inline-flex}
    .cache-refresh{position:fixed;right:14px;top:12px;z-index:45;appearance:none;border:1px solid #91c0aa;background:#eff9f2;color:#285243;border-radius:999px;padding:5px 9px;font-size:12px;line-height:1.2;cursor:pointer;box-shadow:0 6px 14px rgba(29,77,60,.15)}
    .cache-refresh:disabled{opacity:.65;cursor:wait}

    .result-card{
      display:flex;
      flex-direction:column;
      min-height:0;
      height:100%;
      position:relative;
      z-index:1;
    }
    .result-scroll{margin-top:8px;flex:1;min-height:0;overflow-y:auto;padding-right:2px;-webkit-overflow-scrolling:touch}

    table{width:100%;border-collapse:collapse;margin-top:10px;table-layout:fixed}
    th,td{border-bottom:1px solid var(--line);padding:10px 8px;font-size:15px;vertical-align:top}
    th{position:sticky;top:0;background:var(--thead);z-index:1;font-weight:700}
    th:nth-child(1),td:nth-child(1){width:28%}
    th:nth-child(2),td:nth-child(2){width:40%}
    th:nth-child(3),td:nth-child(3){width:32%}
    .ops{display:flex;align-items:center;justify-content:flex-end;gap:8px;flex-wrap:wrap}
    .link-icon{display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;line-height:1;text-decoration:none;font-size:18px;border-radius:8px;color:var(--text)}
    .link-icon:hover{background:#dff1e7}
    .link-icon:active{transform:translateY(1px)}

    .kind-chip{
      display:inline-flex;align-items:center;
      max-width:100%;
      padding:4px 8px;
      border-radius:999px;
      font-size:13px;
      background:var(--chip-bg);
      color:var(--chip-text);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
      border:1px solid var(--line);
    }

    @media (max-width:768px){
      body{padding:10px}
      .list-layout{height:100dvh}
      #filter-panel{
        top:10px;
        width:calc(100vw - 20px);
      }
      .card{padding:14px;border-radius:16px}
      .hero-title{font-size:18px}
      table{display:none}
      .result-scroll{
        scroll-snap-type:y mandatory;
        scroll-behavior:smooth;
      }
      .mobile-list{
        display:block;
        margin-top:0;
        max-height:none;
        overflow:visible;
        -webkit-overflow-scrolling:touch;
        padding-right:2px;
      }
      .item{
        border:1px solid var(--line);
        border-radius:14px;
        padding:12px 10px;
        display:flex;
        flex-direction:column;
        gap:8px;
        background:#f8fffb;
        margin-bottom:9px;
        scroll-snap-align:start;
        scroll-snap-stop:always;
        transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
      }
      .item:active,
      .item:focus-within{
        transform:translateY(-1px) scale(1.01);
        border-color:#84bca2;
        box-shadow:0 10px 18px rgba(29,77,60,.14);
      }
      .l1{font-size:16px;line-height:1.5;font-weight:700;display:flex;gap:6px;flex-wrap:wrap}
      .l1 .sep{opacity:.6}
      .l2{display:flex;align-items:center;gap:8px;justify-content:flex-end;flex-wrap:wrap}
      .dm-select-wrap{flex:7 1 0}
      .dm-btn-wrap{flex:3 1 0}
      .input-dock{padding:8px 10px calc(8px + env(safe-area-inset-bottom))}
      .input-console{padding:9px}
      .to-top{right:10px;bottom:126px}

      .result-card{
        position:fixed;
        left:10px;
        right:10px;
        top:10px;
        bottom:calc(var(--dock-height, 110px) + 8px);
        padding:10px;
      }
      .result-scroll{
        margin-top:0;
        padding-top:var(--initial-mobile-offset, 0px);
      }

      body.filters-collapsed #filter-panel{
        padding:10px 12px 42px;
        margin-bottom:4px;
        max-height:100px;
      }
      body.filters-collapsed #filter-panel .topbar{
        margin-bottom:4px;
      }
      body.filters-collapsed #status{
        font-size:12px;
      }
      body.filters-collapsed .limit-wrap{
        display:none;
      }
      body.filters-collapsed #stats-row,
      body.filters-collapsed #quick-filters{
        display:none;
      }
    }

    body.filters-collapsed #stats-row,
    body.filters-collapsed #quick-filters,
    body.filters-collapsed .limit-wrap{
      display:none;
    }

    .page{display:none}.page.active{display:block}
    .history-header{display:flex;align-items:center;gap:10px;margin-bottom:8px}
    .back{appearance:none;border:1px solid var(--line);background:#eff9f2;color:var(--text);border-radius:10px;padding:8px 12px;font-size:14px;cursor:pointer}
    .back:hover{background:#e2f4e9}
    .title{font-weight:700}
    .history-list{margin-top:8px}
    .history-process{margin-top:10px;padding:10px;border:1px solid var(--line);border-radius:12px;background:#f4fbf7;font-size:13px;color:#33584b}
    .history-process strong{font-size:12px;letter-spacing:.02em;color:#2a4f41}
    .history-debug{margin-top:6px;line-height:1.5;word-break:break-word}
    .history-item{display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--line);padding:10px 4px;gap:8px}
    .history-left{display:flex;align-items:center;gap:8px;min-width:0}
    .history-date{white-space:nowrap;color:#6a867b}
    .history-item a{color:var(--link);text-decoration:none}
    .history-item a:hover{text-decoration:underline}
    .skeleton{height:16px;background:#d9ece2;border-radius:6px;margin:6px 0}

    @supports not selector(:focus-visible){
      :where(button,[href],input,select):focus{outline:3px solid var(--focus);outline-offset:2px}
    }
  </style>
</head>
<body>
  <div class="app-shell">
  <!-- ä¸€è¦§ãƒšãƒ¼ã‚¸ -->
  <div id="page-list" class="page active">
    <div class="list-layout" id="list-layout">
      <div class="card" id="filter-panel">
        <div class="topbar">
          <div class="tabs" role="tablist" aria-label="æ¤œç´¢å¯¾è±¡">
            <button id="tab-songs" class="tab" role="tab" aria-selected="true"  data-tab="songs">æ­Œå”±æ›²</button>
            <button id="tab-gags"  class="tab" role="tab" aria-selected="false" data-tab="gags">ä¸€ç™ºãƒã‚¿</button>
          </div>
          <div class="limit-wrap">
            <label for="limit" class="muted" style="white-space:nowrap;">è¡¨ç¤º</label>
            <select id="limit" aria-label="è¡¨ç¤º">
              <option value="10">10ä»¶</option>
              <option value="50" selected>50ä»¶</option>
              <option value="all">å…¨ã¦</option>
            </select>
          </div>
        </div>

        <div class="muted" id="status">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
        <div class="server-response" id="server-response" aria-live="polite">ã‚µãƒ¼ãƒãƒ¼å¿œç­”: æœªç¢ºèª</div>
        <div class="server-monitor" id="server-monitor" aria-live="polite">
          <div class="server-monitor-head">
            <span class="server-monitor-title">ç¨¼åƒãƒ¢ãƒ‹ã‚¿ãƒ¼</span>
            <button id="server-monitor-refresh" class="btn btn-subtle" type="button">ä»Šã™ãç¢ºèª</button>
          </div>
          <div class="server-monitor-body">
            <div>çŠ¶æ…‹: <span id="monitor-status" class="server-monitor-pill">æœªç¢ºèª</span></div>
            <div>æœ€çµ‚ç¢ºèª: <span id="monitor-last-check">æœªç¢ºèª</span></div>
            <div>é™çš„ãƒ‡ãƒ¼ã‚¿: <span id="monitor-static">æœªç¢ºèª</span></div>
            <div>é…ä¿¡: <span id="monitor-api">æœªç¢ºèª</span></div>
            <div>é€£ç¶šå¤±æ•—: <span id="monitor-fail-count">0</span></div>
            <div>è©³ç´°: <span id="monitor-detail">-</span></div>
          </div>
        </div>
        <div class="stats-row" id="stats-row" aria-live="polite"></div>
        <div class="quick-filters" id="quick-filters" aria-label="åŒºåˆ†ã§çµã‚Šè¾¼ã¿"></div>
      </div>

      <div class="card result-card">
        <div class="muted" id="hint">æ¤œç´¢çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        <div id="results-scroll" class="result-scroll" aria-label="æ¥½æ›²æƒ…å ±ã‚«ãƒ¼ãƒ‰ä¸€è¦§">
          <div id="table" style="display:none;"></div>
          <div id="mblist" class="mobile-list" style="display:none;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- å±¥æ­´ãƒšãƒ¼ã‚¸ -->
  <div id="page-history" class="page">
    <div class="card">
      <div class="history-header">
        <button id="btn-back" class="back">â† æˆ»ã‚‹</button>
        <div class="title" id="hist-title">/</div>
      </div>
      <div class="muted" id="hist-sub">æ­Œå”±å±¥æ­´ã‚’æ–°ã—ã„é †ã«è¡¨ç¤ºã—ã¾ã™ã€‚</div>
      <div id="hist-process" class="history-process" aria-live="polite">
        <strong>å±¥æ­´ãƒšãƒ¼ã‚¸ã§å®Ÿè¡Œä¸­ã®å‡¦ç†</strong>
        <div id="hist-debug" class="history-debug">æœªå®Ÿè¡Œ</div>
      </div>
    </div>
    <div class="card" style="margin-top:12px;">
      <div id="hist-list" class="history-list"></div>
      <div id="hist-empty" class="muted" style="display:none;">è©²å½“ã™ã‚‹å±¥æ­´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ</div>
  <button id="to-top" class="to-top" type="button" aria-label="ãƒšãƒ¼ã‚¸ä¸Šéƒ¨ã¸æˆ»ã‚‹">â†‘ ä¸Šã¸</button>
  <button id="cache-refresh" class="cache-refresh" type="button" title="ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç ´æ£„ã—ã¦å†å–å¾—">æ›´æ–°</button>
  <div class="input-dock" aria-label="å…¥åŠ›ã‚³ãƒ³ã‚½ãƒ¼ãƒ«">
    <div class="input-console">
      <div class="row">
        <input id="q" type="search" placeholder="æ›²åï¼ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆåã§æ¤œç´¢" autocomplete="off">
        <button id="clear-search" class="btn btn-subtle" type="button" title="æ¤œç´¢æ¡ä»¶ã‚’ã‚¯ãƒªã‚¢">ã‚¯ãƒªã‚¢</button>
      </div>
      <div class="dm-wrap" aria-label="å¼¾å¹•ã‚³ãƒ”ãƒ¼">
        <div class="dm-select-wrap">
          <select id="dm-select" title="å¼¾å¹•ã®ç¨®é¡ã‚’é¸æŠ">
            <option value="âš›ï¸ğŸŒê•¤.â€Ë–Ù­*âš›ï¸ğŸŒê•¤.â€Ë–Ù­*âš›ï¸ğŸŒê•¤.â€Ë–Ù­*âš›ï¸ğŸŒê•¤.â€Ë–Ù­*">âš›ï¸ğŸŒê•¤.â€Ë–Ù­ï¼ˆèŠ±ï¼‰</option>
            <option value="âš›ï¸ğŸŒâ™¬*.+âš›ï¸ğŸŒâ™¬*.+âš›ï¸ğŸŒâ™¬*.+âš›ï¸ğŸŒâ™¬*.+">âš›ï¸ğŸŒâ™¬*.+ï¼ˆéŸ³ç¬¦ï¼‰</option>
            <option value="âœ¨âš›ï¸ğŸŒğŸµâœ¨âš›ï¸ğŸŒğŸµâœ¨âš›ï¸ğŸŒğŸµâœ¨âš›ï¸ğŸŒğŸµ">âœ¨âš›ï¸ğŸŒğŸµï¼ˆã‚­ãƒ©éŸ³ç¬¦ï¼‰</option>
          </select>
        </div>
        <div class="dm-btn-wrap">
          <button id="dm-copy" class="btn btn-full" type="button" title="é¸æŠã—ãŸå¼¾å¹•ã‚’ã‚³ãƒ”ãƒ¼">ã‚³ãƒ”ãƒ¼</button>
        </div>
      </div>
    </div>
  </div>
  </div>

  <script>
    const DEFAULT_STATIC_BASE = new URL('./public-data/', window.location.href).toString();
    const DEFAULT_GAS_API_URL = 'https://script.google.com/macros/s/AKfycbw7AIt8edC5Q24Gvvf6o5T7gCbWgWZq53pPbpNsONKsExOHZpxdQronK68ZMj61y1bU/exec';
    function resolveApiUrl(){
      try {
        const byQuery = new URLSearchParams(window.location.search).get('gas_url');
        if (byQuery) return new URL(byQuery, window.location.href).toString();
      } catch {}
      try {
        const byStorage = localStorage.getItem('gasApiUrl');
        if (byStorage) return new URL(byStorage, window.location.href).toString();
      } catch {}
      return DEFAULT_GAS_API_URL;
    }
    function resolveStaticDataBase(){
      try {
        const byQuery = new URLSearchParams(window.location.search).get('static_base');
        if (byQuery) return new URL(byQuery, window.location.href).toString();
      } catch {}
      try {
        const byStorage = localStorage.getItem('staticDataBase');
        if (byStorage) return new URL(byStorage, window.location.href).toString();
      } catch {}
      return DEFAULT_STATIC_BASE;
    }
    const API_URL = resolveApiUrl();
    const DEPLOY_URL = API_URL;
    const STATIC_DATA_BASE = resolveStaticDataBase();
    const HARD_LIMIT = 10000;
    const state = {
      current: 'songs',
      cache: { songs:null, gags:null },
      preloadPromise: null,
      debounce: null,
      initialMobileOffsetConsumed: false,
      historyCache: new Map(),
      archiveRows: [],
      archiveByKey: null,
      archiveByTitle: null,
      lastScroll: 0,
      histKey: null,
      kindFilters: [],
      archiveMeta: {
        phase: 'idle',
        source: 'unknown',
        transport: '-',
        useDeploy: false,
        retry: 0,
        lastError: '',
        rows: 0,
        updatedAt: 0
      },
      serverResponse: {
        inflight: 0,
        lastOkAt: 0,
        lastLabel: '-',
        lastError: ''
      },
      serverMonitor: {
        status: 'unknown',
        lastCheckAt: 0,
        staticOk: false,
        apiOk: false,
        failCount: 0,
        detail: 'æœªç¢ºèª'
      },
      monitorTimer: null,
      snapTimer: null,
      snapLock: false,
      activeSnapIndex: -1
    };

    const $ = id => document.getElementById(id);
    const normalize = s => (s||'').toString().toLowerCase().replace(/\s+/g,' ').trim();
    const showToast = msg => { const t=$('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1400); };
    async function copyText(text){
      try{
        if(navigator.clipboard?.writeText) await navigator.clipboard.writeText(text);
        else{ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); }
        showToast('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
      }catch{ showToast('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ'); }
    }
    async function copyPair(title, artist){
      const text = `${(title||'').trim()} / ${(artist||'').trim()}`.trim();
      await copyText(text);
    }
    document.getElementById('dm-copy').addEventListener('click', ()=>{
      const v = $('dm-select').value || '';
      copyText(v);
    });
    document.getElementById('clear-search').addEventListener('click', ()=>{
      $('q').value = '';
      state.kindFilters = [];
      render();
      $('q').focus();
    });
    function getListScroller(){
      return $('results-scroll');
    }
    function formatTime(ts){
      if (!ts) return 'æœªç¢ºèª';
      return new Date(ts).toLocaleTimeString('ja-JP');
    }
    function renderServerResponse(){
      const el = $('server-response');
      if (!el) return;
      const probe = state.serverResponse;
      el.className = 'server-response';
      if (probe.inflight > 0) {
        el.classList.add('loading');
        el.textContent = `ã‚µãƒ¼ãƒãƒ¼å¿œç­”: é€šä¿¡ä¸­â€¦ï¼ˆ${probe.inflight}ä»¶ï¼‰`;
        return;
      }
      if (probe.lastError) {
        el.classList.add('error');
        el.textContent = `ã‚µãƒ¼ãƒãƒ¼å¿œç­”: å¤±æ•—ï¼ˆ${probe.lastLabel} / ${probe.lastError}ï¼‰`;
        return;
      }
      if (probe.lastOkAt) {
        el.classList.add('ok');
        el.textContent = `ã‚µãƒ¼ãƒãƒ¼å¿œç­”: ${formatTime(probe.lastOkAt)} ã«ç¢ºèªï¼ˆ${probe.lastLabel}ï¼‰`;
        return;
      }
      el.textContent = 'ã‚µãƒ¼ãƒãƒ¼å¿œç­”: æœªç¢ºèª';
    }
    function beginServerRequest(){
      state.serverResponse.inflight += 1;
      renderServerResponse();
    }
    function endServerRequest(ok, label, message = ''){
      state.serverResponse.inflight = Math.max(0, state.serverResponse.inflight - 1);
      state.serverResponse.lastLabel = label || '-';
      if (ok) {
        state.serverResponse.lastOkAt = Date.now();
        state.serverResponse.lastError = '';
      } else {
        state.serverResponse.lastError = message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      }
      renderServerResponse();
    }

    function monitorPillClass(status){
      if (status === 'ok') return 'server-monitor-pill ok';
      if (status === 'warn') return 'server-monitor-pill warn';
      if (status === 'error') return 'server-monitor-pill error';
      return 'server-monitor-pill';
    }
    function renderServerMonitor(){
      const mon = state.serverMonitor;
      const statusEl = $('monitor-status');
      if (!statusEl) return;
      statusEl.className = monitorPillClass(
        mon.status === 'ok' ? 'ok' : mon.status === 'checking' ? 'warn' : mon.status === 'error' ? 'error' : 'warn'
      );
      statusEl.textContent = mon.status === 'ok' ? 'ç¨¼åƒä¸­' : mon.status === 'checking' ? 'ç¢ºèªä¸­' : mon.status === 'error' ? 'è¦ç¢ºèª' : 'æœªç¢ºèª';
      $('monitor-last-check').textContent = formatTime(mon.lastCheckAt);
      $('monitor-static').textContent = mon.staticOk ? 'OK' : (mon.lastCheckAt ? 'NG' : 'æœªç¢ºèª');
      $('monitor-api').textContent = mon.apiOk ? 'OK' : (mon.lastCheckAt ? 'NG' : 'æœªç¢ºèª');
      $('monitor-fail-count').textContent = String(mon.failCount || 0);
      $('monitor-detail').textContent = mon.detail || '-';
    }
    async function fetchWithTimeout(url, timeoutMs = 7000){
      const controller = new AbortController();
      const timer = setTimeout(()=>controller.abort(), timeoutMs);
      try {
        return await fetch(url, { cache: 'no-store', signal: controller.signal });
      } finally {
        clearTimeout(timer);
      }
    }
    function fetchByJsonp(tab, { timeoutMs = REQUEST_TIMEOUT_MS, extraParams = {} } = {}){
      return new Promise((resolve, reject) => {
        const callbackName = `__direct_jsonp_${tab}_${Date.now()}_${Math.random().toString(36).slice(2)}`;
        if (!JSONP_CALLBACK_RE.test(callbackName)) {
          reject(new Error('callbackåã®ç”Ÿæˆã«å¤±æ•—'));
          return;
        }

        const timer = setTimeout(() => {
          cleanup();
          reject(new Error('JSONP timeout'));
        }, timeoutMs);

        let script = null;
        const cleanup = () => {
          clearTimeout(timer);
          if (script && script.parentNode) script.parentNode.removeChild(script);
          delete window[callbackName];
        };

        window[callbackName] = (payload) => {
          cleanup();
          resolve(payload);
        };

        script = document.createElement('script');
        script.src = buildApiRequestUrl(tab, callbackName, false, extraParams);
        script.referrerPolicy = 'no-referrer';
        script.onerror = () => {
          cleanup();
          reject(new Error('JSONP script load error'));
        };
        document.head.appendChild(script);
      });
    }
    async function probeServerHealth({ manual = false } = {}){
      const mon = state.serverMonitor;
      mon.status = 'checking';
      mon.detail = manual ? 'æ‰‹å‹•ãƒã‚§ãƒƒã‚¯ä¸­â€¦' : 'å®šæœŸãƒã‚§ãƒƒã‚¯ä¸­â€¦';
      renderServerMonitor();

      let apiOk = false;
      let staticOk = false;
      let detail = 'æ­£å¸¸';

      try {
        const staticRes = await fetchWithTimeout(buildStaticDataUrl('meta'), 7000);
        staticOk = staticRes.ok;
        if (!staticOk) detail = `é™çš„ãƒ‡ãƒ¼ã‚¿ ${staticRes.status}`;
      } catch (err) {
        const reason = err?.name === 'AbortError' ? 'timeout' : 'network';
        detail = `é™çš„ãƒ‡ãƒ¼ã‚¿å¤±æ•—: ${reason}`;
      }

      try {
        const apiRes = await fetchWithTimeout(buildStaticDataUrl('songs'), 7000);
        apiOk = apiRes.ok;
        if (!apiOk && staticOk) detail = `API ${apiRes.status}`;
      } catch (err) {
        const reason = err?.name === 'AbortError' ? 'timeout' : 'network';
        if (staticOk) detail = `APIå¤±æ•—: ${reason}`;
      }

      mon.lastCheckAt = Date.now();
      mon.staticOk = staticOk;
      mon.apiOk = apiOk;

      if (staticOk && apiOk) {
        mon.status = 'ok';
        mon.failCount = 0;
        mon.detail = 'æ­£å¸¸ï¼ˆR2é™çš„ãƒ‡ãƒ¼ã‚¿å¿œç­”ã‚ã‚Šï¼‰';
      } else if (staticOk || apiOk) {
        mon.status = 'ok';
        mon.failCount = 0;
        mon.detail = staticOk ? 'é™çš„ãƒ‡ãƒ¼ã‚¿å¿œç­”ã‚ã‚Š' : 'é…ä¿¡å¿œç­”ã‚ã‚Š';
      } else {
        mon.status = 'error';
        mon.failCount += 1;
        mon.detail = detail;
      }
      renderServerMonitor();
    }
    function currentScrollTop(){
      if ($('page-list').classList.contains('active')) {
        return getListScroller()?.scrollTop || 0;
      }
      return window.scrollY || document.documentElement.scrollTop || 0;
    }
    function updateViewportMetrics(){
      const dock = $('input-dock');
      if (!dock) return;
      const dockHeight = Math.ceil(dock.getBoundingClientRect().height) + 22;
      document.documentElement.style.setProperty('--dock-height', `${dockHeight}px`);
      syncInitialMobileOffset();
    }

    function syncInitialMobileOffset(){
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      const onListPage = $('page-list').classList.contains('active');
      if (!isMobile || !onListPage || state.initialMobileOffsetConsumed) {
        document.documentElement.style.setProperty('--initial-mobile-offset', '0px');
        return;
      }
      const filterHeight = Math.ceil($('filter-panel').getBoundingClientRect().height);
      document.documentElement.style.setProperty('--initial-mobile-offset', `${Math.max(filterHeight + 10, 0)}px`);
    }
    function runSnapHaptic(){
      if (!window.matchMedia('(max-width: 768px)').matches) return;
      if (typeof navigator.vibrate !== 'function') return;
      navigator.vibrate(14);
    }
    function snapToNearestCard(){
      if (state.snapLock) return;
      if (!$('page-list').classList.contains('active')) return;
      if (!window.matchMedia('(max-width: 768px)').matches) return;
      const scroller = getListScroller();
      if (!scroller) return;
      const cards = Array.from($('mblist').querySelectorAll('.item'));
      if (cards.length === 0) return;

      const top = scroller.scrollTop;
      let nearest = 0;
      let distance = Number.POSITIVE_INFINITY;
      cards.forEach((card, idx)=>{
        const d = Math.abs(card.offsetTop - top);
        if (d < distance) {
          distance = d;
          nearest = idx;
        }
      });

      const target = cards[nearest].offsetTop;
      state.snapLock = true;
      scroller.scrollTo({ top: target, behavior: 'smooth' });
      window.setTimeout(()=>{
        state.snapLock = false;
        if (state.activeSnapIndex !== nearest) {
          state.activeSnapIndex = nearest;
          runSnapHaptic();
        }
      }, 180);
    }
    document.getElementById('to-top').addEventListener('click', ()=>{
      if ($('page-list').classList.contains('active')) {
        getListScroller()?.scrollTo({ top: 0, behavior: 'smooth' });
        return;
      }
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
    document.getElementById('cache-refresh').addEventListener('click', async ()=>{
      const btn = $('cache-refresh');
      btn.disabled = true;

      state.cache.songs = null;
      state.cache.gags = null;
      state.historyCache.clear();
      state.archiveRows = [];
      state.archiveByKey = null;
      state.archiveByTitle = null;
      state.kindFilters = [];
      state.archiveMeta.phase = 'idle';
      state.archiveMeta.source = 'unknown';
      state.archiveMeta.transport = '-';
      state.archiveMeta.useDeploy = false;
      state.archiveMeta.retry = 0;
      state.archiveMeta.lastError = '';
      state.archiveMeta.rows = 0;
      state.archiveMeta.updatedAt = 0;

      $('q').value = '';
      $('status').textContent = 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç ´æ£„ã—ã¦å†å–å¾—ä¸­â€¦';
      $('stats-row').innerHTML = '';
      $('quick-filters').innerHTML = '';
      $('hint').textContent = 'æ¤œç´¢çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚';
      $('table').innerHTML = '';
      $('mblist').innerHTML = '';
      $('table').style.display = 'none';
      $('mblist').style.display = 'none';
      if ($('page-history').classList.contains('active')) {
        $('hist-list').innerHTML = '';
        $('hist-empty').style.display = 'none';
        $('hist-sub').textContent = 'å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—ã—ã¦ã„ã¾ã™â€¦';
      }
      renderHistoryProcess();

      try {
        await warmCaches({ forceReload: true });
        showToast('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç ´æ£„ã—ã¦æ›´æ–°ã—ã¾ã—ãŸ');
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        showToast(`æ›´æ–°ã«å¤±æ•—: ${msg}`);
      } finally {
        btn.disabled = false;
      }
    });

    const urlFromText = s => { if(!s) return ''; const m=String(s).match(/https?:\/\/\S+/); return m ? m[0].replace(/[)\]\s]+$/,'') : ''; };
    const extractDate8 = s => { const m=/^(\d{8})/.exec(String(s||'')); return m ? parseInt(m[1],10) : 0; };

    function showPage(id){
      document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
      $(id).classList.add('active');
      updateViewportMetrics();
    }

    function toHistoryEntries(rows, artist, title){
      const na = normalize(artist);
      const nt = normalize(title);
      const unique = new Set();
      const out = [];
      for(const r of rows || []){
        if (normalize(r.artist) !== na || normalize(r.title) !== nt) continue;
        const url = r.dUrl || urlFromText(r.dText);
        const date = Number(r.date8) || extractDate8(r.dText);
        const kind = (r.kind || '').toString();
        const rowId = String(r.rowId || '').trim();
        const key = rowId || `${date}|${url}|${kind}`;
        if (unique.has(key)) continue;
        unique.add(key);
        out.push({ date, url, kind, rowId });
      }
      return out;
    }

    function sortHistoryEntriesDesc(entries){
      return [...(entries || [])].sort((a, b) => {
        if ((b.date || 0) !== (a.date || 0)) return (b.date || 0) - (a.date || 0);
        return String(b.url || '').localeCompare(String(a.url || ''));
      });
    }

    function mergeHistoryEntriesUnique(...entryLists){
      const seen = new Set();
      const merged = [];
      for (const list of entryLists) {
        for (const entry of list || []) {
          const key = String(entry.rowId || '').trim() || `${entry.date || 0}|${entry.url || ''}|${entry.kind || ''}`;
          if (seen.has(key)) continue;
          seen.add(key);
          merged.push(entry);
        }
      }
      return sortHistoryEntriesDesc(merged);
    }

    function uniqueArchiveRows(rows){
      const seen = new Set();
      const out = [];
      for (const r of rows || []) {
        const key = String(r.rowId || '').trim()
          || `${normalize(r.artist)}|${normalize(r.title)}|${r.kind || ''}|${r.dUrl || ''}`;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(r);
      }
      return out;
    }

    function buildArchiveIndex(rows){
      const sourceRows = uniqueArchiveRows(rows || []);
      state.archiveRows = sourceRows;

      const byKey = new Map();
      const byTitle = new Map();
      for (const r of sourceRows) {
        const artist = normalize(r.artist);
        const title = normalize(r.title);
        const url = r.dUrl || urlFromText(r.dText);
        if (!url) continue;
        const date = Number(r.date8) || extractDate8(r.dText);
        const kind = (r.kind || '').toString();
        const rowId = String(r.rowId || '').trim();
        const key = `${artist}|${title}`;

        if (!byKey.has(key)) byKey.set(key, []);
        byKey.get(key).push({ date, url, kind, rowId });

        if (!byTitle.has(title)) byTitle.set(title, []);
        byTitle.get(title).push({ date, url, kind, rowId });
      }

      byKey.forEach((list, key) => byKey.set(key, sortHistoryEntriesDesc(list)));
      byTitle.forEach((list, key) => byTitle.set(key, sortHistoryEntriesDesc(list)));

      state.archiveByKey = byKey;
      state.archiveByTitle = byTitle;
    }

    function mergeArchiveRows(rows){
      const merged = uniqueArchiveRows([...(state.archiveRows || []), ...(rows || [])]);
      buildArchiveIndex(merged);
      return merged;
    }

    let __jsonpHit = false;
    const REQUEST_MAX_RETRY = 2;
    const REQUEST_TIMEOUT_MS = 8000;
    const REQUEST_RETRY_DELAY_MS = 500;
    const FETCH_TIMEOUT_MS = 10000;
    const INITIAL_ERROR_NOTICE_DELAY_MS = 12000;
    const JSONP_ALLOWED_ORIGIN = 'script.google.com';
    const JSONP_CALLBACK_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    // æ¤œè¨¼æ™‚ã®é€šä¿¡é‡ã¨å¤±æ•—ç‡ã‚’æŠ‘ãˆã‚‹ãŸã‚ã€å–å¾—ä»¶æ•°ã‚’å°ã•ã‚ã«å›ºå®š
    const LIST_FETCH_LIMIT = 500;
    const ARCHIVE_FETCH_LIMIT = 50;
    const ARCHIVE_EXACT_FETCH_LIMIT = 40;
    const INITIAL_FETCH_LIMIT = 50;
    const SECOND_FETCH_LIMIT = 120;
    const ARCHIVE_SAFE_FETCH_LIMIT = 120;
    const ARCHIVE_LIMIT_BACKOFFS = [120, 80, 50, 30, 20, 10];
    const ARCHIVE_PAGE_LIMIT = 30;
    const ARCHIVE_MAX_PAGES = 8;

    const requestState = {
      songs: { id:0, timer:null, inflight:false },
      gags: { id:0, timer:null, inflight:false },
      archive: { id:0, timer:null, inflight:false }
    };

    function clearRequestTimer(tab){
      const req = requestState[tab];
      if (!req) return;
      if (req.timer) clearTimeout(req.timer);
      req.timer = null;
    }
    function markRequestSuccess(tab){
      if (!requestState[tab]) return;
      const req = requestState[tab];
      req.inflight = false;
      clearRequestTimer(tab);
    }
    function showRequestError(tab, reason){
      if (state.current === tab || !state.cache[state.current]) {
        $('status').textContent = `ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆ${tab}ï¼‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ${reason}`;
      }
    }

    function showHistoryLoadError(message){
      if (!$('page-history').classList.contains('active')) return;
      const wrap = $('hist-list');
      const empty = $('hist-empty');
      wrap.innerHTML = '';
      empty.style.display = 'block';
      $('hist-sub').textContent = message;
      state.archiveMeta.phase = 'error';
      state.archiveMeta.lastError = message;
      renderHistoryProcess();
    }

    function renderHistoryProcess(){
      const meta = state.archiveMeta;
      const updated = meta.updatedAt ? new Date(meta.updatedAt).toLocaleTimeString('ja-JP') : 'æœªå–å¾—';
      const mode = meta.useDeploy ? 'deploy URL' : 'é€šå¸¸ URL';
      let phaseLabel = 'å¾…æ©Ÿä¸­';
      if (meta.phase === 'loading') phaseLabel = 'å–å¾—ä¸­';
      else if (meta.phase === 'ready') phaseLabel = 'è¡¨ç¤ºæº–å‚™å®Œäº†';
      else if (meta.phase === 'error') phaseLabel = 'ã‚¨ãƒ©ãƒ¼';

      $('hist-debug').innerHTML = [
        `çŠ¶æ…‹: <b>${phaseLabel}</b>`,
        `ãƒ‡ãƒ¼ã‚¿æº: ${meta.source}`,
        `å–å¾—æ‰‹æ®µ: ${meta.transport} (${mode})`,
        `å†è©¦è¡Œå›æ•°: ${meta.retry}`,
        `å±¥æ­´ä»¶æ•°: ${meta.rows}`,
        `æœ€çµ‚æ›´æ–°: ${updated}`,
        meta.lastError ? `ã‚¨ãƒ©ãƒ¼è©³ç´°: ${meta.lastError}` : 'ã‚¨ãƒ©ãƒ¼è©³ç´°: ãªã—'
      ].join('<br>');
    }

    function handleRequestFailure(tab, attempt, reason){
      const req = requestState[tab];
      if (!req) return;
      req.inflight = false;
      clearRequestTimer(tab);

      if (attempt < REQUEST_MAX_RETRY) {
        const next = attempt + 1;
        const retryTransport = (tab === 'archive' && state.archiveMeta.transport === 'fetch')
          ? 'fetch'
          : 'jsonp';
        if (tab === 'archive') {
          state.archiveMeta.phase = 'loading';
          state.archiveMeta.retry = next;
          state.archiveMeta.lastError = reason;
          renderHistoryProcess();
        }
        console.warn(`[${tab}] request failed: ${reason}. retry=${next}/${REQUEST_MAX_RETRY}`);
        setTimeout(()=>requestData(tab, next, false, retryTransport), REQUEST_RETRY_DELAY_MS * next);
        return;
      }

      if (tab === 'archive') {
        state.archiveMeta.phase = 'error';
        state.archiveMeta.lastError = reason;
        showHistoryLoadError(`å±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${reason}`);
      }
      showRequestError(tab, reason);
    }

    function normalizeBaseRow(r){
      if (Array.isArray(r)) {
        return {
          artist: r[0] ?? '',
          title : r[1] ?? '',
          kind  : r[2] ?? '',
          dText : r[3] ?? '',
          dUrl  : r[4] ?? '',
          date8 : Number(r[5]) || extractDate8(r[3]),
          rowId : String(r[6] ?? '').trim()
        };
      }
      const row = r && typeof r === 'object' ? r : {};
      const dText = row.dText  ?? row.dtext  ?? row.DTEXT ?? row.text ?? row.source ?? row['å‡ºå…¸å…ƒæƒ…å ±(ç›´ãƒªãƒ³ã‚¯)'] ?? row.å‡ºå…¸å…ƒæƒ…å ± ?? row.å‡ºå…¸ ?? '';
      const dUrl = row.dUrl   ?? row.durl   ?? row.DURL  ?? row.url ?? row.directUrl ?? row.link ?? '';
      const date8Raw = row.date8 ?? row.date ?? row.æŠ•ç¨¿æ—¥ ?? row.postedDate ?? '';
      const date8 = Number(date8Raw) || extractDate8(dText);
      const rowId = String(row.rowId ?? row.rowid ?? '').trim();
      return {
        artist: row.artist ?? row.Artist ?? row.artistName ?? row.singer ?? row.ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ ?? row.ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆå ?? row.æ­Œæ‰‹å ?? '',
        title : row.title  ?? row.Title  ?? row.song ?? row.songName ?? row.æ›²å ?? row.æ¥½æ›²å ?? '',
        kind  : row.kind   ?? row.Kind   ?? row.category ?? row.type ?? row.åŒºåˆ† ?? '',
        dText,
        dUrl,
        date8,
        rowId,
      };
    }
    function normalizeListRows(payloadRows){
      return (payloadRows || [])
        .map(normalizeBaseRow)
        .filter(r => ((r.artist||'')+(r.title||'')).trim() !== '');
    }
    function normalizeArchiveRows(payloadRows){
      return (payloadRows || [])
        .map(normalizeBaseRow)
        .filter(r => {
          const hasMain = ((r.artist||'') + (r.title||'')).trim() !== '';
          const hasArchiveOnly = String(r.dText||'').trim() !== '' || String(r.dUrl||'').trim() !== '';
          return hasMain || hasArchiveOnly;
        });
    }

    function resolvePayloadRows(payload){
      const visited = new Set();
      const queue = [payload];

      while (queue.length) {
        const cur = queue.shift();
        if (!cur || visited.has(cur)) continue;
        if (typeof cur === 'object') visited.add(cur);

        if (Array.isArray(cur)) {
          if (cur.length === 0 || Array.isArray(cur[0]) || typeof cur[0] === 'object') return cur;
          continue;
        }

        if (typeof cur !== 'object') continue;

        const directCandidates = [
          cur.rows,
          cur.data,
          cur.list,
          cur.items,
          cur.records,
          cur.values,
          cur.result && cur.result.rows,
          cur.result && cur.result.data,
          cur.payload && cur.payload.rows,
          cur.payload && cur.payload.data,
          cur.response && cur.response.rows,
          cur.response && cur.response.data
        ];
        for (const candidate of directCandidates) {
          if (Array.isArray(candidate)) return candidate;
        }

        for (const v of Object.values(cur)) {
          if (v && typeof v === 'object') queue.push(v);
        }
      }
      return null;
    }

    function normalizeArchiveCandidate(item){
      if (!item || typeof item !== 'object') return null;
      return {
        artist: item.artist ?? item.Artist ?? item.artistName ?? item.singer ?? item.ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ ?? item.ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆå ?? item.æ­Œæ‰‹å ?? '',
        title : item.title  ?? item.Title  ?? item.song ?? item.songName ?? item.æ›²å ?? item.æ¥½æ›²å ?? '',
        kind  : item.kind   ?? item.Kind   ?? item.category ?? item.type ?? item.åŒºåˆ† ?? '',
        dText : item.dText  ?? item.dtext  ?? item.DTEXT ?? item.text ?? item.source ?? item.memo ?? item.note ?? item.å‡ºå…¸ ?? item.å‡ºå…¸å…ƒæƒ…å ± ?? '',
        dUrl  : item.dUrl   ?? item.durl   ?? item.DURL  ?? item.url ?? item.directUrl ?? item.link ?? item.href ?? ''
      };
    }

    function extractArchiveRowsFallback(payload){
      if (Array.isArray(payload)) return payload;
      if (!payload || typeof payload !== 'object') return null;

      const direct = [
        payload.rows,
        payload.data,
        payload.list,
        payload.items,
        payload.records,
        payload.values,
        payload.result,
        payload.payload,
        payload.response,
        payload.archive,
        payload.histories,
        payload.history
      ];
      for (const candidate of direct) {
        if (Array.isArray(candidate)) return candidate;
      }

      const normalizedSingle = normalizeArchiveCandidate(payload);
      if (normalizedSingle && ((normalizedSingle.artist + normalizedSingle.title + normalizedSingle.dText + normalizedSingle.dUrl).trim() !== '')) {
        return [payload];
      }

      for (const value of Object.values(payload)) {
        if (Array.isArray(value) && value.length > 0) {
          const first = value[0];
          if (typeof first === 'object' || Array.isArray(first)) return value;
        }
      }
      return null;
    }

    function parsePayloadLoose(payload){
      if (typeof payload !== 'string') return payload;
      const text = payload.trim();
      if (!text) return payload;
      try {
        return JSON.parse(text);
      } catch {
        return payload;
      }
    }

    function normalizeRowsForTab(tab, payload){
      const parsed = parsePayloadLoose(payload);
      const rowsPayload = resolvePayloadRows(parsed) || (tab === 'archive' ? extractArchiveRowsFallback(parsed) : null);
      if (!rowsPayload) {
        const serverError = parsed && typeof parsed === 'object'
          ? (parsed.error || parsed.message || (parsed.result && parsed.result.error))
          : '';
        throw new Error(serverError ? `ä¸æ­£ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹: ${serverError}` : 'ä¸æ­£ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹');
      }

      const rawSheet = String(parsed?.sheet || parsed?.sheetName || parsed?.name || '').toLowerCase();
      const shouldStrictMatch = tab === 'songs' || tab === 'gags';
      if (shouldStrictMatch && rawSheet && rawSheet !== tab) {
        throw new Error(`å–å¾—å…ƒä¸ä¸€è‡´: request=${tab}, response=${rawSheet}`);
      }

      if (tab === 'archive') return normalizeArchiveRows(rowsPayload);
      return normalizeListRows(rowsPayload).map(r => ({
        ...r,
        _na: normalize(r.artist),
        _nt: normalize(r.title)
      }));
    }

    function handlePayload(tab, payload){
      __jsonpHit = true;
      const rows = normalizeRowsForTab(tab, payload);

      if (tab === 'songs' || tab === 'gags') {
        markRequestSuccess(tab);
        state.cache[tab] = rows;

        if (state.cache[state.current]) {
          $('status').textContent = `èª­ã¿è¾¼ã¿å®Œäº†ï¼š${state.cache[state.current].length}ä»¶`;
          render();
        } else {
          $('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦';
        }
        return;
      }

      if (tab === 'archive') {
        markRequestSuccess(tab);
        buildArchiveIndex(rows);
        state.archiveMeta.phase = 'ready';
        state.archiveMeta.source = 'network';
        state.archiveMeta.retry = 0;
        state.archiveMeta.lastError = '';
        state.archiveMeta.rows = rows.length;
        state.archiveMeta.updatedAt = Date.now();
        renderHistoryProcess();
        if (state.histKey) renderHistory(state.histKey.artist, state.histKey.title);
        return;
      }

      throw new Error('ä¸æ˜ãªã‚¿ãƒ–ç¨®åˆ¥');
    }

    function isListDataReady(){
      return Boolean(state.cache.songs || state.cache.gags);
    }
    function isListRequestInflight(){
      return Boolean(requestState.songs?.inflight || requestState.gags?.inflight);
    }

    setTimeout(()=>{
      if (__jsonpHit) return;
      if (!$('page-list').classList.contains('active')) return;
      if (isListDataReady()) return;
      if (isListRequestInflight()) return;
      $('status').textContent = 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆR2é™çš„ãƒ‡ãƒ¼ã‚¿è¨­å®šã‚’ç¢ºèªï¼‰';
    }, INITIAL_ERROR_NOTICE_DELAY_MS);

    function toSafeApiBase(rawUrl){
      const src = String(rawUrl || '').replace(/\/macros\/u\/\d+\//,'/macros/');
      const u = new URL(src);
      if (u.protocol !== 'https:') throw new Error('API URLã¯httpsã®ã¿è¨±å¯ã—ã¦ã„ã¾ã™');
      if (u.hostname !== JSONP_ALLOWED_ORIGIN) throw new Error('è¨±å¯ã•ã‚Œã¦ã„ãªã„JSONPãƒ›ã‚¹ãƒˆã§ã™');
      if (!/^\/macros\/s\/[A-Za-z0-9_-]+\/exec$/.test(u.pathname)) throw new Error('API URLå½¢å¼ãŒä¸æ­£ã§ã™');
      return u;
    }

    function buildApiRequestUrl(tab, callbackName, useDeploy, extraParams = {}){
      const base = toSafeApiBase(useDeploy ? DEPLOY_URL : API_URL);
      const params = new URLSearchParams({
        callback: callbackName,
        sheet: tab,
        authuser: '0',
        v: String(Date.now())
      });
      if (tab === 'songs' || tab === 'gags') params.set('limit', String(LIST_FETCH_LIMIT));
      if (tab === 'archive') params.set('limit', String(ARCHIVE_FETCH_LIMIT));
      Object.entries(extraParams || {}).forEach(([k,v]) => {
        if (v !== null && v !== undefined && `${v}` !== '') params.set(k, String(v));
      });
      base.search = params.toString();
      return base.toString();
    }
    function buildApiFetchUrl(tab, useDeploy, extraParams = {}){
      const base = toSafeApiBase(useDeploy ? DEPLOY_URL : API_URL);
      const params = new URLSearchParams({
        sheet: tab,
        authuser: '0',
        v: String(Date.now())
      });
      if (tab === 'songs' || tab === 'gags') params.set('limit', String(LIST_FETCH_LIMIT));
      if (tab === 'archive') params.set('limit', String(ARCHIVE_FETCH_LIMIT));
      Object.entries(extraParams || {}).forEach(([k,v]) => {
        if (v !== null && v !== undefined && `${v}` !== '') params.set(k, String(v));
      });
      base.search = params.toString();
      return base.toString();
    }
    function buildStaticDataUrl(tab){
      const base = new URL(STATIC_DATA_BASE, window.location.href);
      const filename = tab === 'meta' ? 'meta.json' : `${tab}.json`;
      return new URL(filename, base).toString();
    }
    async function fetchStaticMeta(){
      const res = await fetchWithTimeout(buildStaticDataUrl('meta'), 7000);
      if (!res.ok) throw new Error(`static meta: HTTP ${res.status}`);
      const payload = await res.json();
      if (payload?.ok === false) throw new Error('static meta: ok=false');
      return payload && typeof payload === 'object' ? payload : {};
    }
    function validateStaticRowsWithMeta(tab, rows, meta){
      if (!meta || typeof meta !== 'object') return { ok: true, reason: '' };

      const tabs = Array.isArray(meta.tabs) ? meta.tabs.map(v => String(v).toLowerCase()) : null;
      if (tabs && tabs.length > 0 && !tabs.includes(tab)) {
        return { ok: false, reason: `meta.tabs ã« ${tab} ãŒã‚ã‚Šã¾ã›ã‚“` };
      }

      const expected = meta?.counts?.[tab];
      if (Number.isFinite(Number(expected))) {
        const expectedCount = Number(expected);
        if (rows.length !== expectedCount) {
          return { ok: false, reason: `ä»¶æ•°ä¸ä¸€è‡´ static=${rows.length}, meta=${expectedCount}` };
        }
      }

      return { ok: true, reason: '' };
    }
    async function fetchStaticSnapshot(tab){
      const res = await fetchWithTimeout(buildStaticDataUrl(tab), 7000);
      if (!res.ok) throw new Error(`static ${tab}: HTTP ${res.status}`);
      const payload = await res.json();
      if (payload?.ok === false) throw new Error(`static ${tab}: ok=false`);
      return normalizeRowsForTab(tab, payload);
    }

    function jsonp(tab, attempt, useDeploy = false){
      const req = requestState[tab];
      if (!req) return;

      clearRequestTimer(tab);
      beginServerRequest();
      req.id += 1;
      req.inflight = true;
      if (tab === 'archive') {
        state.archiveMeta.phase = 'loading';
        state.archiveMeta.source = 'network';
        state.archiveMeta.transport = 'jsonp';
        state.archiveMeta.useDeploy = useDeploy;
        state.archiveMeta.retry = attempt;
        renderHistoryProcess();
      }
      const requestId = req.id;
      const callbackName = `__jsonp_${tab}_${Date.now()}_${Math.random().toString(36).slice(2)}`;
      if (!JSONP_CALLBACK_RE.test(callbackName)) {
        handleRequestFailure(tab, attempt, 'callbackåã®ç”Ÿæˆã«å¤±æ•—');
        return;
      }

      let script = null;
      const cleanup = () => {
        clearRequestTimer(tab);
        if (script && script.parentNode) script.parentNode.removeChild(script);
        script = null;
        delete window[callbackName];
      };

      window[callbackName] = (payload) => {
        if (req.id !== requestId) return;
        req.inflight = false;
        cleanup();
        try {
          handlePayload(tab, payload);
          endServerRequest(true, `${tab}/jsonp`);
        } catch (err) {
          const reason = err instanceof Error ? err.message : String(err);
          endServerRequest(false, `${tab}/jsonp`, reason);
          if (!useDeploy && reason.startsWith('å–å¾—å…ƒä¸ä¸€è‡´')) {
            console.warn(`[${tab}] ${reason}. deploy URLã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚`);
            requestData(tab, attempt, true);
            return;
          }
          handleRequestFailure(tab, attempt, reason);
        }
      };

      script=document.createElement('script');
      script.src = buildApiRequestUrl(tab, callbackName, useDeploy);
      script.referrerPolicy = 'no-referrer';
      script.onerror=()=>{
        if (req.id !== requestId) return;
        req.inflight = false;
        cleanup();
        endServerRequest(false, `${tab}/jsonp`, 'scriptèª­è¾¼å¤±æ•—');
        requestData(tab, attempt, useDeploy, 'fetch');
      };
      document.head.appendChild(script);

      req.timer = setTimeout(()=>{
        if (req.id !== requestId || !req.inflight) return;
        req.inflight = false;
        cleanup();
        endServerRequest(false, `${tab}/jsonp`, 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ');
        requestData(tab, attempt, useDeploy, 'fetch');
      }, REQUEST_TIMEOUT_MS);
    }
    async function requestByFetch(tab, attempt, useDeploy = false){
      const req = requestState[tab];
      if (!req) return;

      clearRequestTimer(tab);
      req.id += 1;
      req.inflight = true;
      if (tab === 'archive') {
        state.archiveMeta.phase = 'loading';
        state.archiveMeta.source = 'network';
        state.archiveMeta.transport = 'fetch';
        state.archiveMeta.useDeploy = useDeploy;
        state.archiveMeta.retry = attempt;
        renderHistoryProcess();
      }
      const requestId = req.id;

      const controller = new AbortController();
      beginServerRequest();
      req.timer = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);

      try {
        const res = await fetch(buildApiFetchUrl(tab, useDeploy), {
          signal: controller.signal,
          mode: 'cors',
          credentials: 'omit',
          cache: 'no-store'
        });
        if (req.id !== requestId) return;
        req.inflight = false;
        clearRequestTimer(tab);

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const text = await res.text();
        let payload;
        try {
          payload = JSON.parse(text);
        } catch {
          payload = text;
        }
        handlePayload(tab, payload);
        endServerRequest(true, `${tab}/fetch`);
      } catch (err) {
        if (req.id !== requestId) return;
        req.inflight = false;
        clearRequestTimer(tab);

        const reason = err && err.name === 'AbortError'
          ? 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
          : 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/ãƒ–ãƒ­ãƒƒã‚¯';
        endServerRequest(false, `${tab}/fetch`, reason);
        handleRequestFailure(tab, attempt, reason);
      }
    }
    function requestData(tab, attempt = 0, useDeploy = false, transport = 'jsonp'){
      if (requestState[tab]?.inflight && attempt === 0) return;
      if (transport === 'fetch') {
        requestByFetch(tab, attempt, useDeploy);
        return;
      }
      jsonp(tab, attempt, useDeploy);
    }

    function ensureArchiveFast(){
      renderHistoryProcess();
      if (!requestState.archive.inflight) requestData('archive', 0, false, 'fetch');
    }

    async function fetchArchiveRowsByQuery(query, limit = ARCHIVE_SAFE_FETCH_LIMIT){
      const opts = { q: query, limit };
      const run = async (useDeploy = false) => {
        beginServerRequest();
        try {
          const res = await fetch(buildApiFetchUrl('archive', useDeploy, opts), {
            mode: 'cors',
            credentials: 'omit',
            cache: 'no-store'
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const rows = normalizeRowsForTab('archive', await res.text());
          endServerRequest(true, 'archive/fetch(query)');
          return rows;
        } catch (err) {
          const reason = err instanceof Error ? err.message : String(err);
          endServerRequest(false, 'archive/fetch(query)', reason);
          throw err;
        }
      };

      try {
        return await run(false);
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        if (msg.startsWith('å–å¾—å…ƒä¸ä¸€è‡´')) return run(true);
        throw err;
      }
    }

    function isArgumentTooLargeErrorMessage(message){
      const msg = (message || '').toString();
      return msg.includes('å¼•æ•°ãŒå¤§ãã™ãã¾ã™') || msg.toLowerCase().includes('argument too large');
    }

    function buildArchiveLimitCandidates(limit){
      const upper = Number.isFinite(limit) && limit > 0 ? Math.floor(limit) : ARCHIVE_SAFE_FETCH_LIMIT;
      const candidates = [upper, ...ARCHIVE_LIMIT_BACKOFFS.filter(v => v < upper)];
      return [...new Set(candidates.filter(v => Number.isFinite(v) && v > 0))];
    }

    function archiveRowKey(row){
      const normalized = normalizeBaseRow(row);
      return String(normalized.rowId || '').trim() || [
        normalize(normalized.artist),
        normalize(normalized.title),
        normalize(normalized.kind),
        normalize(normalized.dUrl)
      ].join('|');
    }

    async function fetchArchiveRowsChunked(limit = ARCHIVE_SAFE_FETCH_LIMIT){
      const pageLimit = Math.max(1, Math.min(ARCHIVE_PAGE_LIMIT, Math.floor(limit || ARCHIVE_PAGE_LIMIT)));
      const maxPages = Math.max(1, Math.min(ARCHIVE_MAX_PAGES, Math.ceil(limit / pageLimit)));

      const merged = [];
      const seenKeys = new Set();
      let repeatedPageCount = 0;

      for (let page = 0; page < maxPages; page++) {
        const offset = page * pageLimit;
        const rows = await fetchSheetRowsWithFallback('archive', { limit: pageLimit, offset });
        if (!Array.isArray(rows) || rows.length === 0) break;

        let added = 0;
        for (const row of rows) {
          const key = archiveRowKey(row);
          if (seenKeys.has(key)) continue;
          seenKeys.add(key);
          merged.push(normalizeBaseRow(row));
          added++;
        }

        if (added === 0) {
          repeatedPageCount++;
          if (repeatedPageCount >= 1) break;
        } else {
          repeatedPageCount = 0;
        }

        if (rows.length < pageLimit) break;
      }

      return normalizeArchiveRows(merged).slice(0, limit);
    }

    async function fetchArchiveRowsResilient({ query = '', limit = ARCHIVE_SAFE_FETCH_LIMIT } = {}){
      const candidates = buildArchiveLimitCandidates(limit);
      let lastErr = null;

      for (let i = 0; i < candidates.length; i++) {
        const candidateLimit = candidates[i];
        try {
          if ((query || '').trim()) {
            return await fetchArchiveRowsByQuery(query, candidateLimit);
          }
          return await fetchArchiveRowsChunked(candidateLimit);
        } catch (err) {
          lastErr = err;
          const msg = err instanceof Error ? err.message : String(err);
          const canRetrySmaller = isArgumentTooLargeErrorMessage(msg) && i < candidates.length - 1;
          if (!canRetrySmaller) throw err;
        }
      }

      if (lastErr) throw lastErr;
      return [];
    }

    async function fetchSheetRows(tab, useDeploy = false, extraParams = {}){
      beginServerRequest();
      try {
        const res = await fetch(buildApiFetchUrl(tab, useDeploy, extraParams), {
          mode: 'cors',
          credentials: 'omit',
          cache: 'no-store'
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const rows = normalizeRowsForTab(tab, await res.text());
        endServerRequest(true, `${tab}/fetch(stage)`);
        return rows;
      } catch (err) {
        const reason = err instanceof Error ? err.message : String(err);
        endServerRequest(false, `${tab}/fetch(stage)`, reason);
        throw err;
      }
    }

    async function fetchSheetRowsWithFallback(tab, extraParams = {}){
      try {
        return await fetchSheetRows(tab, false, extraParams);
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        if (msg.startsWith('å–å¾—å…ƒä¸ä¸€è‡´')) {
          return fetchSheetRows(tab, true, extraParams);
        }
        return fetchSheetRows(tab, true, extraParams);
      }
    }

    async function fetchInStages(tab, { onStage } = {}){
      const limits = tab === 'archive'
        ? [INITIAL_FETCH_LIMIT, ARCHIVE_SAFE_FETCH_LIMIT]
        : [INITIAL_FETCH_LIMIT, SECOND_FETCH_LIMIT, null];
      let lastRows = [];
      for (let i = 0; i < limits.length; i++) {
        const limit = limits[i];
        const params = limit ? { limit } : {};
        try {
          const rows = tab === 'archive'
            ? await fetchArchiveRowsResilient({ limit: limit || ARCHIVE_SAFE_FETCH_LIMIT })
            : await fetchSheetRowsWithFallback(tab, params);
          lastRows = rows;
          if (typeof onStage === 'function') onStage(rows, { limit, stage: i + 1 });
          if (limit && rows.length < limit) break;
        } catch (err) {
          if (i === 0) throw err;
          break;
        }
      }
      return lastRows;
    }

    async function warmCaches({ forceReload = false } = {}){
      if (state.preloadPromise) return state.preloadPromise;
      if (!forceReload && state.cache.songs && state.cache.gags && state.archiveByKey && state.archiveByTitle) {
        return;
      }

      state.preloadPromise = (async () => {
        beginServerRequest();
        $('status').textContent = 'songs / gags ã‚’R2é™çš„ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—ä¸­â€¦';

        try {
          const [metaStatic, songsStatic, gagsStatic] = await Promise.allSettled([
            fetchStaticMeta(),
            fetchStaticSnapshot('songs'),
            fetchStaticSnapshot('gags')
          ]);

          const staticMeta = metaStatic.status === 'fulfilled' ? metaStatic.value : null;
          const songsStaticCheck = songsStatic.status === 'fulfilled'
            ? validateStaticRowsWithMeta('songs', songsStatic.value, staticMeta)
            : { ok: false, reason: songsStatic.reason instanceof Error ? songsStatic.reason.message : 'static songs å–å¾—å¤±æ•—' };
          const gagsStaticCheck = gagsStatic.status === 'fulfilled'
            ? validateStaticRowsWithMeta('gags', gagsStatic.value, staticMeta)
            : { ok: false, reason: gagsStatic.reason instanceof Error ? gagsStatic.reason.message : 'static gags å–å¾—å¤±æ•—' };

          if (!songsStaticCheck.ok) console.warn(`[static] songs ã‚’ä¸æ¡ç”¨: ${songsStaticCheck.reason}`);
          if (!gagsStaticCheck.ok) console.warn(`[static] gags ã‚’ä¸æ¡ç”¨: ${gagsStaticCheck.reason}`);

          if (!songsStaticCheck.ok) throw new Error(`songs èª­ã¿è¾¼ã¿å¤±æ•—: ${songsStaticCheck.reason}`);
          if (!gagsStaticCheck.ok) throw new Error(`gags èª­ã¿è¾¼ã¿å¤±æ•—: ${gagsStaticCheck.reason}`);
          const songsRows = songsStatic.value;
          const gagsRows = gagsStatic.value;

          state.cache.songs = songsRows;
          state.cache.gags = gagsRows;
          buildArchiveIndex(state.archiveRows || []);

          if (state.archiveMeta.phase === 'idle' || state.archiveMeta.phase === 'error') {
            state.archiveMeta.source = 'gas-direct';
            state.archiveMeta.transport = 'jsonp(exact)';
            state.archiveMeta.useDeploy = false;
            state.archiveMeta.retry = 0;
            state.archiveMeta.lastError = '';
            state.archiveMeta.rows = state.archiveRows.length;
            state.archiveMeta.updatedAt = Date.now();
          }
          renderHistoryProcess();

          if (state.cache[state.current]) {
            $('status').textContent = `èª­ã¿è¾¼ã¿å®Œäº†ï¼š${state.cache[state.current].length}ä»¶`;
            render();
          }

          if ($('page-history').classList.contains('active') && state.histKey) {
            renderHistory(state.histKey.artist, state.histKey.title);
          }
          endServerRequest(true, 'warmCaches/static');
        } catch (err) {
          const msg = err instanceof Error ? err.message : String(err);
          state.archiveMeta.phase = 'error';
          state.archiveMeta.lastError = msg;
          renderHistoryProcess();
          $('status').textContent = `ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${msg}`;
          endServerRequest(false, 'warmCaches/static', msg);
          throw err;
        } finally {
          state.preloadPromise = null;
        }
      })();

      return state.preloadPromise;
    }

    function setActiveTab(tab){
      state.current = tab;
      state.kindFilters = [];
      document.querySelectorAll('.tab').forEach(b => b.setAttribute('aria-selected', String(b.dataset.tab===tab)));
      $('status').textContent='èª­ã¿è¾¼ã¿ä¸­â€¦';
      if (!state.cache[tab]) {
        warmCaches().catch(()=>{});
      }
      if (state.cache[tab]) {
        $('status').textContent = `è¡¨ç¤ºä¸­ï¼š${state.cache[tab].length}ä»¶`;
        render();
      }
    }

    function getMergedHistoryList(artist, title){
      const listRows = state.current === 'gags' ? state.cache.gags : state.cache.songs;
      const listEntries = toHistoryEntries(listRows || [], artist, title);
      const key = `${normalize(artist)}|${normalize(title)}`;
      const archiveByKey = state.archiveByKey?.get(key) || [];
      return mergeHistoryEntriesUnique(listEntries, archiveByKey);
    }

    async function fetchSongHistoryFromArchive(artist, title){
      const cacheKey = `${normalize(artist)}|${normalize(title)}`;
      if (state.historyCache.has(cacheKey)) return state.historyCache.get(cacheKey);

      const task = (async () => {
        if (!artist || !title) return;

        state.archiveMeta.phase = 'loading';
        state.archiveMeta.source = 'gas-direct';
        state.archiveMeta.transport = 'jsonp(exact)';
        state.archiveMeta.lastError = '';
        renderHistoryProcess();

        beginServerRequest();
        let rows = [];
        try {
          const payload = await fetchByJsonp('archive', {
            extraParams: {
              artist,
              title,
              exact: '1',
              limit: ARCHIVE_EXACT_FETCH_LIMIT
            }
          });
          rows = normalizeRowsForTab('archive', payload);
          endServerRequest(true, 'archive/jsonp(exact)');
        } catch (err) {
          const reason = err instanceof Error ? err.message : String(err);
          endServerRequest(false, 'archive/jsonp(exact)', reason);
          throw err;
        }

        const filtered = normalizeArchiveRows(rows).filter((r) =>
          normalize(r.artist) === normalize(artist) && normalize(r.title) === normalize(title)
        );

        const mergedRows = mergeArchiveRows(filtered);
        state.archiveMeta.phase = 'ready';
        state.archiveMeta.source = 'gas-direct';
        state.archiveMeta.transport = 'jsonp(exact)';
        state.archiveMeta.retry = 0;
        state.archiveMeta.lastError = '';
        state.archiveMeta.rows = mergedRows.length;
        state.archiveMeta.updatedAt = Date.now();
        renderHistoryProcess();
      })();
      state.historyCache.set(cacheKey, task);
      try {
        await task;
      } finally {
        state.historyCache.delete(cacheKey);
      }
    }

    function renderHistory(artist, title){
      state.histKey = { artist, title };
      $('hist-title').textContent = `${artist || ''} / ${title || ''}`;
      renderHistoryProcess();

      const wrap = $('hist-list');
      const empty = $('hist-empty');
      wrap.innerHTML = '';
      empty.style.display = 'none';

      for(let i=0;i<6;i++){ const sk=document.createElement('div'); sk.className='skeleton'; wrap.appendChild(sk); }
      $('hist-sub').textContent = 'å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ã—ã¦ã„ã¾ã™â€¦';

      if (!state.archiveByKey || !state.archiveByTitle) {
        warmCaches().catch(()=>{});
        return;
      }

      const drawHistory = () => {
        const mergedList = getMergedHistoryList(artist, title);
        wrap.innerHTML = '';

        if (mergedList.length===0){
          empty.style.display = 'block';
          $('hist-sub').textContent = 'è©²å½“ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
          return;
        }

        $('hist-sub').textContent = 'æ–°ã—ã„é †ã«è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';

        const CHUNK = 50;
        let i = 0;
        function drawChunk(){
          const frag = document.createDocumentFragment();
          const end = Math.min(i+CHUNK, mergedList.length);
          for(; i<end; i++){
            const {date,url,kind} = mergedList[i];
            const yyyy = Math.floor(date/10000), mm=Math.floor((date%10000)/100), dd=date%100;
            const dateLabel = date ? `${yyyy}/${String(mm).padStart(2,'0')}/${String(dd).padStart(2,'0')}` : '----/--/--';

            const row = document.createElement('div'); row.className='history-item';

            const left = document.createElement('div'); left.className='history-left';
            const dt = document.createElement('span');
            dt.className = 'history-date';
            dt.textContent = dateLabel;
            left.appendChild(dt);
            if ((kind || '').trim() !== '') {
              const k = document.createElement('span');
              k.className = 'kind-chip';
              k.textContent = kind;
              left.appendChild(k);
            }

            const right = document.createElement('div');
            if (url) { const a=document.createElement('a'); a.href=url; a.target='_blank'; a.rel='noopener'; a.textContent='â–¶ é–‹ã'; right.appendChild(a); }
            else { const span=document.createElement('span'); span.className='muted'; span.textContent='ãƒªãƒ³ã‚¯ãªã—'; right.appendChild(span); }

            row.appendChild(left); row.appendChild(right);
            frag.appendChild(row);
          }
          wrap.appendChild(frag);
          if (i < mergedList.length) requestAnimationFrame(drawChunk);
        }
        requestAnimationFrame(drawChunk);
      };

      drawHistory();
      fetchSongHistoryFromArchive(artist, title)
        .then(() => {
          if (!state.histKey) return;
          if (normalize(state.histKey.artist) !== normalize(artist) || normalize(state.histKey.title) !== normalize(title)) return;
          drawHistory();
        })
        .catch((err) => {
          const msg = err instanceof Error ? err.message : String(err);
          $('hist-sub').textContent = `å±¥æ­´å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${msg}`;
        });
    }

    function openHistory(artist, title){
      state.lastScroll = currentScrollTop();
      document.body.classList.remove('filters-collapsed');
      showPage('page-history');
      renderHistory(artist, title);
    }

    function updateCompactFilterMode(scrollY = currentScrollTop()){
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      const onListPage = $('page-list').classList.contains('active');
      const autoCollapse = isMobile && onListPage && scrollY > 70;
      const collapsed = onListPage && autoCollapse;
      document.body.classList.toggle('filters-collapsed', collapsed);
    }

    function normalizeKindFilters(allKinds){
      if (!Array.isArray(state.kindFilters) || state.kindFilters.length === 0) {
        state.kindFilters = [...allKinds];
        return;
      }
      const selected = new Set(state.kindFilters);
      state.kindFilters = allKinds.filter(kind => selected.has(kind));
      if (state.kindFilters.length === 0 && allKinds.length > 0) {
        state.kindFilters = [...allKinds];
      }
    }

    function appendItemActions(target, {artist, title, kind, dText, dUrl}){
      if ((kind||'').trim()!==''){
        const k=document.createElement('span'); k.className='kind-chip'; k.textContent=kind;
        target.appendChild(k);
      }

      const url = dUrl || urlFromText(dText);
      if (url){
        const a=document.createElement('a'); a.href=url; a.target='_blank'; a.rel='noopener'; a.className='link-icon'; a.textContent='â–¶'; a.title='ãƒªãƒ³ã‚¯ã‚’é–‹ã';
        target.appendChild(a);
      }

      const hbtn=document.createElement('button'); hbtn.className='btn'; hbtn.textContent='å±¥æ­´';
      hbtn.addEventListener('click', ()=>openHistory(artist, title));
      target.appendChild(hbtn);

      const btn=document.createElement('button'); btn.className='btn'; btn.textContent='ã‚³ãƒ”ãƒ¼';
      btn.addEventListener('click', ()=>copyPair(title,artist));
      target.appendChild(btn);
    }
    function render(){
      const tableWrap = $('table'); tableWrap.innerHTML = '';
      const listWrap  = $('mblist'); listWrap.innerHTML = '';
      const hint = $('hint');

      if (!state.cache[state.current]) {
        $('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦';
        tableWrap.style.display = 'none';
        listWrap.style.display  = 'none';
        return;
      }

      const q = normalize($('q').value||'');
      const rawLimit = $('limit').value;
      const limitParsed = (rawLimit === 'all') ? Number.POSITIVE_INFINITY : parseInt(rawLimit,10) || 10;
      const effectiveLimit = Math.min(limitParsed, HARD_LIMIT);

      const allRows = state.cache[state.current] || [];
      const kinds = [...new Set(allRows.map(r => (r.kind || '').trim()).filter(Boolean))].slice(0, 10);
      normalizeKindFilters(kinds);
      const selectedKinds = new Set(state.kindFilters);
      const filterByKinds = kinds.length > 0 && state.kindFilters.length < kinds.length;

      let filtered = allRows;
      if(q){ filtered = filtered.filter(r => r._na.includes(q) || r._nt.includes(q)); }
      if (filterByKinds) filtered = filtered.filter(r => selectedKinds.has((r.kind || '').trim()));
      const rows = filtered.slice(0, effectiveLimit);

      const uniqueArtists = new Set(allRows.map(r => r._na).filter(Boolean)).size;
      const stats = [
        `${state.current === 'songs' ? 'æ­Œå”±æ›²' : 'ä¸€ç™ºãƒã‚¿'}: ${allRows.length}ä»¶`,
        `ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆæ•°: ${uniqueArtists}äºº`
      ];
      $('stats-row').innerHTML = stats.map(text => `<span class="pill">${text}</span>`).join('');

      const filterButtons = kinds.map(kind => {
        const active = selectedKinds.has(kind);
        return `<button type="button" class="filter-chip${active ? ' active' : ''}" data-kind="${kind}">${kind}</button>`;
      }).join('');
      $('quick-filters').innerHTML = filterButtons;
      $('quick-filters').querySelectorAll('.filter-chip').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const kind = btn.dataset.kind || '';
          if (!kind) return;
          const next = new Set(state.kindFilters);
          if (next.has(kind)) next.delete(kind);
          else next.add(kind);
          state.kindFilters = kinds.filter(name => next.has(name));
          if (state.kindFilters.length === 0) {
            state.kindFilters = [...kinds];
          }
          render();
        });
      });

      const limitLabel = (rawLimit === 'all') ? 'å…¨ã¦' : `${effectiveLimit}ä»¶`;
      $('status').textContent = q
        ? `${rows.length}ä»¶ãƒ’ãƒƒãƒˆï¼ˆå…¨${filtered.length}ä»¶ï¼‰ï¼è¡¨ç¤ºä¸Šé™ ${limitLabel}`
        : `è¡¨ç¤ºä¸­ ${rows.length}ä»¶ï¼ˆå…¨${(state.cache[state.current]||[]).length}ä»¶ï¼‰ï¼è¡¨ç¤ºä¸Šé™ ${limitLabel}`;

      if(rows.length===0){
        hint.textContent = q ? 'è©²å½“ãªã—' : 'æ¤œç´¢çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚';
        tableWrap.style.display = 'none';
        listWrap.style.display  = 'none';
        state.activeSnapIndex = -1;
        return;
      }
      hint.textContent = '';

      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      if (!isMobile) {
        state.activeSnapIndex = -1;
        const table=document.createElement('table');
        const thead=document.createElement('thead');
        const trh=document.createElement('tr');
        ['ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆå','æ›²å','æ“ä½œ'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
        thead.appendChild(trh); table.appendChild(thead);

        const tbody=document.createElement('tbody');
        rows.forEach(({artist,title,kind,dText,dUrl})=>{
          const tr=document.createElement('tr');

          let td=document.createElement('td'); td.textContent=artist||''; tr.appendChild(td);
          td=document.createElement('td'); td.textContent=title||''; tr.appendChild(td);

          const tdOps=document.createElement('td');
          const ops=document.createElement('div'); ops.className='ops';

          appendItemActions(ops, {artist, title, kind, dText, dUrl});

          tdOps.appendChild(ops); tr.appendChild(tdOps); tbody.appendChild(tr);
        });
        table.appendChild(tbody); tableWrap.appendChild(table);
        tableWrap.style.display = 'block'; listWrap.style.display = 'none';
      } else {
        rows.forEach(({artist,title,kind,dText,dUrl})=>{
          const item=document.createElement('div'); item.className='item';
          const l1=document.createElement('div'); l1.className='l1';
          const a1=document.createElement('span'); a1.className='artist'; a1.textContent=artist||'';
          const sep=document.createElement('span'); sep.className='sep'; sep.textContent='/';
          const t1=document.createElement('span'); t1.className='title'; t1.textContent=title||'';
          l1.appendChild(a1); l1.appendChild(sep); l1.appendChild(t1);

          const l2=document.createElement('div'); l2.className='l2';

          appendItemActions(l2, {artist, title, kind, dText, dUrl});

          item.appendChild(l1); item.appendChild(l2); $('mblist').appendChild(item);
        });
        $('mblist').style.display = 'block'; $('table').style.display = 'none';
        state.activeSnapIndex = 0;
      }
    }

    $('btn-back').addEventListener('click', ()=>{
      showPage('page-list');
      const scroller = getListScroller();
      if (scroller) scroller.scrollTop = state.lastScroll || 0;
      updateCompactFilterMode(state.lastScroll || 0);
    });

    window.addEventListener('resize', ()=>{
      clearTimeout(state.debounce);
      state.debounce=setTimeout(()=>{
        updateViewportMetrics();
        render();
        updateCompactFilterMode();
      },150);
    });
    window.addEventListener('scroll', ()=>{
      if (!$('page-list').classList.contains('active')) {
        const y = window.scrollY || document.documentElement.scrollTop || 0;
        $('to-top').classList.toggle('show', y > 280);
      }
    });

    getListScroller().addEventListener('scroll', ()=>{
      const y = getListScroller().scrollTop || 0;
      if (y > 0 && !state.initialMobileOffsetConsumed) {
        state.initialMobileOffsetConsumed = true;
        syncInitialMobileOffset();
      }
      $('to-top').classList.toggle('show', y > 280 && $('page-list').classList.contains('active'));
      updateCompactFilterMode(y);
      if (state.snapTimer) clearTimeout(state.snapTimer);
      state.snapTimer = setTimeout(snapToNearestCard, 110);
    });

    (function init(){
      document.getElementById('tab-songs').addEventListener('click', ()=> setActiveTab('songs'));
      document.getElementById('tab-gags').addEventListener('click',  ()=> setActiveTab('gags'));
      $('q').addEventListener('input', ()=>{ clearTimeout(state.debounce); state.debounce=setTimeout(render,200); });
      $('limit').addEventListener('change', render);
      $('server-monitor-refresh').addEventListener('click', ()=>{
        probeServerHealth({ manual: true }).catch(()=>{});
      });

      showPage('page-list');
      updateViewportMetrics();
      setActiveTab('songs');
      warmCaches().catch(()=>{});
      renderServerMonitor();
      probeServerHealth().catch(()=>{});
      state.monitorTimer = setInterval(()=>{
        probeServerHealth().catch(()=>{});
      }, 30000);
      updateCompactFilterMode();

    })();
  </script>
</body>
</html>
